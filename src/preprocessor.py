import os
import ants
import numpy as np
import nibabel as nib
from scipy.stats import skew
from nilearn.image import resample_to_img
from utils import create_directory_if_not_exists, convert_windows_path_to_wsl, run_in_wsl


class Preprocessor:
	def __init__(self):
		"""
		Initialize the Preprocessor to handle tasks related to MRI image pre-processing.
		"""
		# Data paths
		self.root_data_path = os.getenv('ROOT_DATA_PATH')
		self.raw_nifti_path = os.path.join(self.root_data_path, 'raw_data\\nifti\\')
		self.processed_data_path = os.path.join(self.root_data_path, 'processed_data\\')
		self.template_windows_root_path = os.path.join(self.root_data_path, 'template\\')
		self.brain_template_wsl_path = '/usr/local/fsl/data/standard/MNI152_T1_1mm_brain.nii.gz'
		self.brain_mask_wsl_path = '/usr/local/fsl/data/standard/MNI152_T1_1mm_brain_mask.nii.gz'
		self.brain_template_windows_path = os.path.join(self.template_windows_root_path, 'MNI152_T1_1mm_brain.nii.gz')
		self.brain_mask_windows_path = os.path.join(self.template_windows_root_path, 'MNI152_T1_1mm_brain_mask.nii.gz')

		# Download MNI152 T1 1mm template to register images
		try:
			# Ensure output directory exists
			create_directory_if_not_exists(self.template_windows_root_path)
   
			# Copy brain template from FSL to the project directory
			command = [
				'chmod +r',
				self.brain_template_wsl_path,
			]

			result = run_in_wsl(command)

			command = [
				'cp',
				self.brain_template_wsl_path,
				convert_windows_path_to_wsl(self.brain_template_windows_path)
			]

			result = run_in_wsl(command)

			# Copy brain mask from FSL to the project directory
			command = [
				'chmod +r',
				self.brain_mask_wsl_path,
			]

			result = run_in_wsl(command)

			command = [
				'cp',
				self.brain_mask_wsl_path,
				convert_windows_path_to_wsl(self.brain_mask_windows_path)
			]

			result = run_in_wsl(command)

			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during reorientation: {result.stderr}")
		
		except Exception as e:
			print(f"Error during reorientation: {e}")


	def __remove_file(self, file_path):
		"""Helper method to remove a file if it exists."""
		try:
			os.remove(file_path)
		except OSError as e:
			pass


	def __extract_prefix(self, file_name):
		"""
		Extract the prefix from a file name up to the first underscore.

		:param file_name: str, name of the file to extract the prefix from.
		:returns: str, extracted prefix from the file name.
		"""
		parts = file_name.split('_')

		return '_'.join(parts[:2]) if len(parts) > 1 else file_name


	def __remove_non_output_files(self, dir_path: str, desired_file: str) -> None:
		"""
		Remove all files in a directory with the same prefix as the specified desired file,
		except for the desired file itself.

		:param dir_path: str, path to the directory containing the files.
		:param desired_file: str, name of the file to keep in the directory.
		"""
		desired_prefix = self.__extract_prefix(os.path.basename(desired_file))

		for file_name in os.listdir(dir_path):
			file_path = os.path.join(dir_path, file_name)
			current_prefix = self.__extract_prefix(file_name)

			if file_path != desired_file and current_prefix == desired_prefix and os.path.isfile(file_path):
				self.__remove_file(file_path)


	def convert_nib_to_ants(self, nifti_img):
		# Convert the nibabel image objects to ANTsPy images
		return ants.from_numpy(nifti_img.get_fdata(), spacing=nifti_img.header.get_zooms(), origin=[0,0,0], direction=nifti_img.affine[:3, :3])


	def analyze_image(self, nifti_image_path: str):
		"""
		Extract basic features from the NIfTI image that will help in dynamically adjusting parameters.

		:param nifti_image_path: str, path to the NIfTI image file.
		:return: Tuple containing mean intensity and standard deviation of the image.
		"""
		img = nib.load(nifti_image_path)
		data = img.get_fdata(dtype=np.float32)
		
		# Extract fundamental characteristics
		features = {
			'mean_intensity': np.mean(data),
			'std_intensity': np.std(data),
			'intensity_range': np.ptp(data),
			'skewness': skew(data.flatten())
		}
		
		return features


	def check_transformation_matrix(self, matrix_path):
		"""
		Checks the transformation matrix generated by FLIRT.
		
		:param matrix_path: str, path to the .mat file containing the transformation matrix.
		"""
		with open(matrix_path, 'r') as file:
			content = file.read()
			print("Transformation Matrix:\n", content)


	def show_nifti_image(self, image_path: str, overlay_image_path: str = None):
		"""
		Display a NIfTI image using ANTsPy, with optional overlay.

		:param image_path: strm, path of image to display
		:param overlay_image_path: str, optional path of image to display as overlay
		"""
		try:
			# Read NIfTI image
			img = ants.image_read(image_path)

			# Display image with optional overlay
			if overlay_image_path:
				ants.plot(img, overlay=ants.image_read(overlay_image_path), title='NIfTI Image', axis=2)
			else:
				ants.plot(img, title='NIfTI Image', axis=2)

		except Exception as e:
			print(f"Error displaying NIfTI image: {e}")


	def reorient_to_RAS(self, image_path: str, output_path: str):
		"""
		Reorients a NIfTI image to RAS (Right, Anterior, Superior) orientation.

		:param: image_path: str, path to the original NIfTI image.
		:param: output_path: str, where to save the reoriented NIfTI image.
		"""
		try:
			img = nib.load(image_path)
			data = img.get_fdata()
			affine = img.affine

			# Get current orientation
			current_ornt = nib.orientations.io_orientation(affine)

			# Target orientation (RPI)
			target_ornt = nib.orientations.axcodes2ornt(('R', 'A', 'S'))

			# Compute the transform
			transform = nib.orientations.ornt_transform(current_ornt, target_ornt)

			# Apply the transformation
			reoriented_data = nib.orientations.apply_orientation(data, transform)
			
			# Compute the new affine
			new_affine = np.dot(affine, nib.orientations.inv_ornt_aff(transform, data.shape))

			# Save reoriented image
			nib.save(nib.Nifti1Image(reoriented_data, new_affine), output_path)

		except Exception as e:
			print(f"Error during reorientation to RAS: {e}")
   
		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	def align_image_to_std(self, image_path: str, output_path: str):
		"""
		Aligns a NIfTI image to standard orientation using FSL's fslreorient2std.

		:param: image_path: str, path to the input NIfTI image.
		:param: output_path: str, path to save the reoriented NIfTI image.
		"""
		try:
			command = [
				'fslreorient2std',
				convert_windows_path_to_wsl(image_path),
				convert_windows_path_to_wsl(output_path)
			]

			# Execute the command within WSL
			result = run_in_wsl(command)

			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during aligment to standard: {result.stderr}")
		
		except Exception as e:
			print(f"Error during alignment to standard: {e}")

		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	def skull_strip(self, image_path, output_path):
		"""
		Perform skull stripping on an MRI image using FSL's BET within WSL from a Windows-based Python script.

		:param img: str, path to the noise-reduced NIfTI file.
		"""
		try:
			command = [
				'bet',
				convert_windows_path_to_wsl(image_path),
				convert_windows_path_to_wsl(output_path),
				'-f', '0.15',	# Adjust if you know the fractional intensity threshold
				'-g', '0',		# Adjust if you know the gradient direction
				'-B'			# Apply brain bias correction
			]

			# Run the command and capture the output
			result = run_in_wsl(command)
	
			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during skull stripping: {result.stderr}")

		except Exception as e:
			print(f"Error during skull stripping: {e}")

		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)

 
	def reslice_image(self, image_path: str, output_path: str, template_path: str):
		"""
		Reslice image to adjust voxel spacing using nibabel and scipy.

		:param image_path: str, path to the input NIfTI file to be resliced.
		:param template_path: str, path to the MNI152 template NIfTI file.
		"""
		try:
			# Return resampled image to match the template's shape and affine
			resampled_img = resample_to_img(
				source_img=nib.load(image_path),
				target_img=nib.load(template_path),
				interpolation='linear',
				force_resample=True,
				copy_header=True
			)
	
			nib.save(resampled_img, output_path)

		except Exception as e:
			print(f"Error during reslicing image: {e}")

		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	def normalize_intensity(self, image_path: str, output_path: str):
		"""
		Normalize the intensity of a NIfTI image using ANTsPy.

		:param image_path: str, path to the input NIfTI file.
		:param output_path: str, path where the normalized image will be saved.
		"""
		try:
			img = nib.load(image_path)
			data = img.get_fdata()
			
			# Scale intensities to [0, 1]
			data_min = data.min()
			data_max = data.max()
			if data_max > data_min:  # Avoid divide-by-zero
				data = (data - data_min) / (data_max - data_min)

			nib.save(nib.Nifti1Image(data, img.affine, img.header), output_path)
   
		except Exception as e:
			print(f"Error during normalizing intensity: {e}")

		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	def bias_field_correction(self, image_path: str, output_path: str):
		"""
		Apply bias field correction to an image using FSL's N4BiasFieldCorrection within WSL from a Windows-based Python script.

		:param image_path: str, path to the input NIfTI file.
		:param output_path: str, path where the bias-corrected image will be saved.
		"""
		try:
			command = [
				'N4BiasFieldCorrection',
				'-i', convert_windows_path_to_wsl(image_path),
				'-o', convert_windows_path_to_wsl(output_path),
				'-d', '3',						# Specify dimensionality explicitly
				'-s', '1',						# Shrink factor for speed-up, keeping it low for better accuracy
				'-c', '[50x50x50,0.0001]'		# Convergence criteria for refinement and precision
			]

			# Run the command and capture the output
			result = run_in_wsl(command)

			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during bias field correction: {result.stderr}")
		
		except Exception as e:
			print(f"Error during bias field correction: {e}")

		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	def noise_reduction(self, image_path: str, output_path: str, features: dict):
		"""
		Apply noise reduction using FSL's SUSAN within WSL from a Windows-based Python script.

		:param image_path: str, path to the input NIfTI file.
		:param output_path: str, path where the noise-reduced image will be saved.
		:param features: dict, image intensity features for dynamic adjustment.
		"""
  
		# Apply noise reduction from WSL using ANTS
		try:
			# Calculate brightness threshold and smoothing scale dynamically
			mean_intensity = features.get('mean_intensity')
			std_intensity = features.get('std_intensity')
			brightness_threshold = np.clip(250 + std_intensity * (mean_intensity / 500),200, 500)
			smoothing_scale = np.clip(0.6 * (1 + std_intensity / mean_intensity), 0.5, 1.5)

			command = [
				'susan',
				convert_windows_path_to_wsl(image_path),
				str(brightness_threshold),	# Brightness threshold - typical for brain MRIs
				str(smoothing_scale),	# Common choice for smoothing scale in mm
				'3',	# Use full 3D smoothing
				'0',	# Don't use median filter to handle spot noise
				'0',	# Number of USANs: typically 0 for standard image processing
				convert_windows_path_to_wsl(output_path),
			]

			# Run the command and capture the output
			result = run_in_wsl(command)

			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during noise reduction: {result.stderr}")
	
		except Exception as e:
			print(f"Error during noise reduction: {e}")
   
		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)
   

	def register_with_antspy(self, image_path: str, output_path: str, template_path: str):
		"""
		Register an image to a template using ANTsPy.
		:param image_path: Path to the moving image that needs to be registered.
		:param output_path: Path where the registered image will be saved.
		:param template_path: Path to the fixed reference image (template).
		"""
		try:
			# Load images as ANTs image objects
			moving = ants.image_read(image_path)
			fixed = ants.image_read(template_path)
			
			moving = ants.iMath(moving, 'Normalize')
			fixed = ants.iMath(fixed, 'Normalize')

			# Start with initial coarse registration
			# registration_affine = ants.registration(
			# 	fixed=fixed,
			# 	moving=moving,
			# 	type_of_transform='AffineFast',  # A faster variation for initial alignment
			# 	reg_iterations=(50, 20, 0)
			# )

			# # Apply transformation to refine using SyN if extreme accuracy remains needed
			# registration_syn = ants.registration(
			# 	fixed=fixed,
			# 	moving=registration_affine['warpedmovout'],
			# 	type_of_transform='SyN',
			# 	syn_metric='CC',
			# 	reg_iterations=(50, 30, 10)  # Further reduced iterations
			# )

			# # Apply transform to the moving image
			# registered_image = ants.apply_transforms(
			# 	fixed=fixed,
			# 	moving=moving,
			# 	transformlist=registration_syn['fwdtransforms']
			# )
	
	
			# Fast Affine registration
			registration_affine = ants.registration(
				fixed=fixed,
				moving=moving,
				type_of_transform='SyN'
			)

			# Transform with Affine
			registered_image = ants.apply_transforms(
				fixed=fixed,
				moving=moving,
				transformlist=registration_affine['fwdtransforms']
			)

			ants.image_write(registered_image, output_path)

		except Exception as e:
			print(f"Error during registring: {e}")

		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	'''
	def register_image(self, image_path: str, output_path: str, template_path: str):
		"""
		Register an image to a template using FSL's FLIRT (FMRIB's Linear Image Registration Tool) within WSL from a Windows-based Python script.

		:param fixed_image_path: str, path to the fixed reference image.
		:param moving_image_path: str, path to the moving image that needs to be aligned.
		:param output_transformed_path: str, WSL path where the registered image will be saved.
		"""
		try:
			# Ensure output directory exists
			create_directory_if_not_exists(os.path.dirname(output_path))

			command = [
				'flirt',
				'-in', convert_windows_path_to_wsl(image_path),
				'-ref', convert_windows_path_to_wsl(template_path),
				'-out', convert_windows_path_to_wsl(output_path),
				'-omat', convert_windows_path_to_wsl(output_path.replace('.nii.gz', '.mat')),
				'-dof', '12',  # Degrees of freedom for affine transformation
				'-interp', 'trilinear',  # Ensure proper interpolation
				'-searchrx', '-30', '30',  # Rotation limits
				'-searchry', '-30', '30',
				'-searchrz', '-30', '30'
				]

			# Run the command and capture the output
			result = run_in_wsl(command)

			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during registration: {result.stderr}")

		except Exception as e:
			print(f"Error during registration: {e}")
	'''

	def segment_tissue(self, image_path: str, output_path: str):
		"""
		Segments an MRI image using FSL's FAST within WSL from a Windows-based Python script.
		
		CSF (Cerebrospinal Fluid) generally has the lowest intensity.
		GM (Grey Matter) usually has medium intensity.
		WM (White Matter) typically has the highest intensity.

		:param image_path: str, path to the preprocessed brain image (without the skull).
		:param output_path: str, path where segmented tissues will be saved.
		"""
		try:
			command = [
				'fast',
				'-t', '1',  # Image type: 1 for T1-weighted
				'-o', convert_windows_path_to_wsl(output_path),
				'-n', '3',  # Number of tissue-type classes
				'-H', '0.1',  # Spatial smoothness
				'-I', '4',  # Number of main iterations
				convert_windows_path_to_wsl(image_path)
			]

			# Run the command and capture the output
			result = run_in_wsl(command)
	
			# Print the output and errors
			if result.returncode != 0:
				pass
				# raise Exception(f"Error during tissue segmentation: {result.stderr}")

		except Exception as e:
			print(f"Error during tissue segmentation: {e}")
   
		finally:
			# Ensure temporary files are removed after processing is complete
			self.__remove_non_output_files(dir_path=os.path.dirname(output_path), desired_file=output_path)


	def process_image(self, image_path: str):
		"""
		Process the MRI image step-by-step, dynamically adjusting parameters for each step.

		:param image_path: str, path to the raw MRI image in NIfTI format.
		"""

		# Generate paths for the output of each preprocessing step
		output_path = os.path.dirname(image_path.replace(self.raw_nifti_path, self.processed_data_path))
		skull_stripped_path = image_path.replace('.nii', '_brain.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		aligned_path = image_path.replace('.nii', '_aligned.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		reoriented_path = image_path.replace('.nii', '_reoriented.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		bias_corrected_path = image_path.replace('.nii', '_biascorr.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		normalized_path = image_path.replace('.nii', '_norm.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		# denoised_path = image_path.replace('.nii', '_denoised.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		registered_path = image_path.replace('.nii', '_registered.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)
		resliced_path = image_path.replace('.nii', '_resliced.nii.gz').replace(self.raw_nifti_path, self.processed_data_path)

		# Create output directory if it does not exist
		create_directory_if_not_exists(output_path)

		# Execute preprocessing pipeline
		try:
			self.skull_strip(image_path=image_path, output_path=skull_stripped_path)
			self.align_image_to_std(image_path=skull_stripped_path, output_path=aligned_path)
			self.reorient_to_RAS(image_path=aligned_path, output_path=reoriented_path)
			self.bias_field_correction(image_path=reoriented_path, output_path=bias_corrected_path)
			self.normalize_intensity(image_path=bias_corrected_path, output_path=normalized_path)
			# self.noise_reduction(image_path=normalized_path, output_path=denoised_path, features=self.analyze_image(image_path))
			self.register_with_antspy(image_path=normalized_path, output_path=registered_path, template_path=self.brain_template_windows_path)
			self.reslice_image(image_path=registered_path, output_path=resliced_path, template_path=self.brain_template_windows_path)

		except Exception as e:
			print(f"Error during processing series {image_path}: {e}")
			return